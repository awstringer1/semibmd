---
title: "Semi-parametric Benchmark Dosing with semibmd"
author: "Alex Stringer"
date: "`r Sys.Date()`"
output: github_document
  
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,warning=FALSE,message=FALSE)
```

# Install the `semibmd` package

The package is hosted at https://github.com/awstringer1/semibmd. It's currently a private repo so you can't install using e.g. `remotes::install_github`. Instead, clone the repository to a local directory, say
`~/work/projects/benchmark-dose/code/semibmd` for example,
and then in `R` do:
```{r install_it}
install.packages(pkgs='~/work/projects/benchmark-dose/code/semibmd',repos=NULL,type='source')
library(semibmd)
```

# Simulate some data

Simulate some data to which the dose-response model is to be fit:
```{r simulate_data}
n <- 1000
f <- function(x) exp(-5*x)
xmin <- 0
xmax <- 1
xcov <- seq(xmin,xmax,length.out=n)
x1 <- runif(n,xmin,xmax)
x2 <- runif(n,xmin,xmax)
set.seed(43798)
dat <- data.frame(y = rnorm(n,f(xcov)+2*x1-x2,1),x = xcov,x1=x1,x2=x2)
head(dat)
```

The exposure variable is `x` and there are two additional variables `x1` and `x2` that
can be included in the model.

# Benchmark dosing

## Fit the model

Fit the dose-response model and calculate the benchmark dose information:
```{r fitmodel}
mod <- benchmark_dose(y~s(x,bs='mpd')+x1+x2,
                      data=dat,
                      exposure = 'x',
                      x0=0,
                      p0=.05,
                      BMR=.05,
                      monotone = TRUE)
```

The first argument to `benchmark_dose` is a formula compatible with `scam::scam` (if `monotone=TRUE`) or with `mgcv::gam` (if `monotone=FALSE`). The `scam` package accepts
formulas just like `gam`, with the addition that terms you want to be monotone should
have their bases specified manually to be one of the special monotone spline basis. See
`?scam::scam` for a list. Here I chose `bs='mpd'` for "monotone p-spline, decreasing", to
enforce a monotone-decreasing estimated curve.

If you choose `monotone = TRUE` then `scam` is used; I added the option to choose `monotone=FALSE` and fit an ordinary `gam`, based on our discussions. However, I have not yet tested this feature.

The rest of the arguments are fairly self-explanatory. You have to tell it which
variable is the exposure variable (that you want the BMD(L) for) using `exposure=...`. You
can look at `?benchmark_dose` for the full documentation.

## Get the summaries

Summaries and plots are obtained the usual way:
```{r summary_plot}
summary(mod)
plot(mod)
```

The `summary` method just appends the estimated BMD(L) onto the summary from the
dose-response model. The `plot` method just adds vertical lines to the plotted `scam/gam`
at the BMD and BMDL.

For more detailed access, you can get the actual fitted model using `get_model(mod)`
and the estimated BMD(L) using `get_bmd(mod)`.

## Regular non-monotone GAM

We can also fit a regular `gam` by setting `montone = FALSE`. In this case, you change the basis in the formula to be
something compatible with `mgcv`:
```{r fitmodelgam}
mod <- benchmark_dose(y~s(x,bs='bs')+x1+x2, # B-spline
                      data=dat,
                      exposure = 'x',
                      x0=0,
                      p0=.05,
                      BMR=.05,
                      monotone = FALSE)
```

Summaries and plots are obtained the same way:
```{r summary_plot_gam}
summary(mod)
plot(mod)
```

# Alternative BMDL Calculation

I have added functionality for computing BMDLs using the delta method and bootstrapping. The argument `BMDL` in the
call to `benchmark_dose` controls which BMDL(s) is/are calculated; current options are `all` (default), `score` and `delta`.
Note that the contents of the `bmdl` slot in the output object is never anything other than the `score` BMDL; the `delta` BMDL
is stored elsewhere and accessed using a getter function, see below.

The argument `boot` controls the number of (parametric) bootstrap iterations, with default `0` meaning don't bootstrap. Like the `delta` BMDL,
a bootstrapped BMDL will be stored elsewhere in the output object and accessed using a getter.

Here is how to fit it:
```{r fitmodelallbmdl}
mod <- benchmark_dose(y~s(x,bs='bs')+x1+x2,
                      data=dat,
                      exposure = 'x',
                      x0=0,
                      p0=.05,
                      BMR=.05,
                      monotone = TRUE,
                      BMDL = 'all',
                      boot = 200
)
```

The `summary` method still returns just the `score` BMDL. Here are the various getter functions to get everything:
```{r getters}
# BMD and score BMDL:
get_bmd(mod)
# All BMDLs:
get_all_bmdl(mod)
```

# Errors and diagnostics

The `benchmark_dose` function does error checking/handling at each step of the procedure and
attempts to collate and report the errors in a safe manner. If you get an actual exception thrown
when using it, let me know what it is and I'll try and add it. You can see what errors were thrown
with the following:
```{r geterrors}
get_errors(mod)
```
This should return `FALSE` if no errors were thrown.

You can see diagnostics and approximation quantities too:
```{r getapprox}
# Diagnostics: U at estimated BMD and Psi at estimated score BMDL.
# Both should be zero:
get_uxb(mod)
get_psixl(mod)
# Approximation quantities: variance and derivative of U at BMD (used for delta method)
get_approximations(mod)
# Computation times of each step
get_computation_times(mod)
```
